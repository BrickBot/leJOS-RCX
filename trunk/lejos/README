
Summary
-------

TINYVM_HOME=<installation directory>
TINYVMPATH=<like classpath>
RCXTTY=<serial device>
PATH=$PATH:$TINYVM_HOME/bin

Tools      : cd $TINYVM_HOME; make
Firmware   : tvmfirmdl $TINYVM_HOME/bin/tinyvm.srec
Compiling  : tvmc <class>.java
Linking    : tvmld <class> -o <class>.tvm
Running    : tvm <class>.tvm

Deleting the TinyVM firmware: Hold Prgm & Run, and press On/Off,
                              while in program-download mode.

Exceptions                  : [XXXX Y], XXXX = method sig.; 
                              Y = exception class index % 10.
                              Press View to continue.

(More details in Setup section below)

What is TinyVM?
---------------

TinyVM is a virtual machine that can execute 
post-processed Java class files inside the Lego
RCX. It's yet another firmware replacement for
the RCX.

TinyVM probably cannot be called a Java virtual 
machine because of certain limitations, lack of 
APIs, and other non-compliance issues. However,
TinyVM supports most of the Java *language*
and comes with a set of APIs for controlling
the RCX.

Technical Information
---------------------

The virtual machine (tinyvm.srec) contains all
the code necessary to execute (post-processed)
Java bytecodes. Source is compiled by a regular
Java compiler. A javac wrapper, tvmc, is provided
to take care of setup issues, like using 
$TINYVM_HOME/lib/classes.jar instead of the
JDK's classes.zip. TINYVMPATH is used instead
of CLASSPATH. (You cannot, of course, include
classes.zip or your favorite Java framework in
TINYVMPATH. Any native methods there won't be
understood by TinyVM. Any APIs you framework
requires from Java probably won't be provided
by TinyVM).

To keep the VM's footprint as small as possible,
no class-loading code was included in it. Instead,
classes are linked together into a compact and
resolved binary format, which is downloaded into
the RCX for execution. (See vmsrc/language.h and
jtools/js/tinyvm/Binary.java for details on the
format).

The RCX is controlled from your Java code through 
native APIs. (See common/signatures.db and vmsrc/native.c).
The native mechanism is very simple: TinyVM and
the linker agree in advance about certain special
method signatures, and classes. The mechanism is 
clearly not JNI compliant, but it suffices.

Requirements
------------

- JDK1.1.7B, available from http://java.sun.com.
  Other VMs should work but they haven't been tested.

- If you're planning to change the source code and
  rebuild it, you should get Kekoa's librcx package,
  build it, and set LIBRCX_HOME to its installation 
  directory.

Setup
-----

Environment:
  - TINYVM_HOME should point to the TinyVM
    installation directory.
  - Your PATH is assumed to point to the 
    JDK's bin directory.
  - You should also add $TINYVM_HOME/bin to
    your PATH.
  - RCXTTY must be defined to point to the
    IR device file. For example, in my system
    it's /dev/ttyS1. I suspect that in most
    Linux systems you have to define it as
    /dev/ttyS0. In Windows (assuming TinyVM
    has been ported) it would be COM1, COM2,
    etc.
  - Before linking, TINYVMPATH should contain
    entries for locating class files, jar files
    or zip files. It works pretty much like
    CLASSPATH does for the JDK.

Building the Tools:
  If the setup is right, simply typing 'make'
  while at $TINYVM_HOME, should build all the
  tools necessary to start using TinyVM.

Downloading the Firmware:
  Simply run:
  tvmfirmdl $TINYVM_HOME/bin/tinyvm.srec

Deleting the Firmware:
  When the TinyVM firmware is ready to download 
  linked binaries (i.e. when it's in program-download
  mode [0000 0]), you can remove the firmware
  by holding both the Prgm and Run buttons down
  while you press the On-Off button. 

Running a Example
-----------------

  1. Go to the example directory.

     cd $TINYVM_HOME/examples/hello

  2. Set the TINYVMPATH variable.
 
     export TINYVMPATH=.

  3. Compile the program.

     tvmc *.java

     Note that this is equivalent to

     javac -classpath .:$TINYVM_HOME/lib/classes.jar *.java 

  4. Link the program.

     tvmld HelloRCX -o HelloRCX.tvm

     This will create the HelloRCX.tvm file,
     which can be downloaded into the RCX.

  5. Download firmware, if necessary.

     tvmfirmdl $TINYVM_HOME/bin/tinyvm.srec

     This may take a couple of minutes. When the
     firmware is done getting downloaded, you
     should hear two beeps, and the LCD should 
     look pretty much like this: [0000 0].
     TinyVM is in program-download mode at 
     this point.

  6. Download the program.

     tvm HelloRCX.tvm
 
     If the RCX is in range, the LCD will show 
     the download count as  the number of bytes 
     divided by 100. (As of this writing, tvm
     does not report communication errors. If TinyVM
     receives bad data, you'll hear beeps, meaning that 
     the firmware is returning to program-download state).
     TinyVM will execute the program, as soon as
     the download has been completed. When 
     all non-daemon threads are finished, 
     the firmware will return to program-download 
     state. (Note that any pending queued tones 
     will not be heard).
    
     As you may have guessed, you can only 
     download programs when the firmware is in
     program-download state.

Exceptions
----------

TinyVM can show an exception "trace" in the RCX's LCD.
It will look like this: [XXXX Y]. You'll also hear a
low buzzing sound, and a wedge (^) will be shown right 
below sensor 2. The meaning of the trace is as follows:

  XXXX = Method signature id.
  Y    = Exception class index % 10.

For example, at the time of this writing, 
if you see a trace that looks like [0000 7],
it probably means that a NullPointerException
(class index = 7) was thrown in method main(String[])
(method signature = 0), and it wasn't caught.

When you link a program with tvmld -verbose, you will 
get a list of class indices and (hopefully by the 
time this is released) one for method signatures.

NOTE: You must press View to continue after you see
an exception trace.

Footprint
---------

Even though tinyvm.srec is about 24 Kb (03/04/00), it
occupies only about 10 Kb in RAM. There's about 18 Kb
of space left for your programs and objects, which is
a good amount.

Footprint is an area that can be improved considerably,
both in native code and linked binaries. On the other
hand, some firmware usability improvements that appear 
to be required will increase the size of the VM. Hopefully
there will be enough contributions in the area of footprint
reduction to balance out part of the enhancements.

Emulation
---------

You should be able to run linked programs in the 
development machine. All you need to do is use
tvmld-emul instead of tvmld, and tvm-emul instead
of tvm. In some cases it might be easier to debug
programs with the emulated VM, and you'll also 
get slightly more detailed exception information.

Limitations
-----------

Due to size constraints, some language features
have been omitted. Others just haven't been 
implemented yet. The limitations that come to 
mind are:

  - Garbage collection is not performed.
    (The number of objects in your program
    should be bounded).
  - Switch statements are not supported.
  - Floating point operations are not supported.
  - Operations on variables of type long are not 
    suported.
  - Maximum array length is 255.
  - String constants are not used by the VM to
    create String objects (i.e. don't use Strings).
  - The instanceof operation will always be true  
    for interfaces. In bytecode, CHECKCAST succeeds
    on all interface classes (which is a bit unsafe).
  - All threads are non-deamon threads. (If you have
    an infinite loop in one thread, the firmware will
    not go back to program-download state).
  - There are no objects of type java.lang.Class, 
    which means that the ".class" construct won't
    work. Class.forName() throws NoSuchMethorError.
  - Most JDK APIs are unavailable.

Known Bugs
----------

  - A StackOverflowError will crash the VM.
  - Finally blocks are not executed if OutOfMemoryErrors
    are thrown.
  - System.arraycopy is currently unimplemented.
    Hence, operations on StringBuffers will
    misbehave.
  - Unknown native methods are not reported.

Documentation
-------------

The only TinyVM documentation currently available is this
README file and the API documentation, which you should
be able to obtain by running:

  javadoc -sourcepath $TINYVM_HOME/classes \
    java.lang tinyvm.rcx -d /tmp

About the License
-----------------

I'm releasing under the Mozilla Public License (see LICENSE)
for now, since librcx is under that same license, and TinyVM 
is linked against -lrcx.

Questions/Problems
------------------

You can contact Jose at jhsolorz@yahoo.com if you 
have any questions, problems, or if you'd like to
contribute to TinyVM in any way.

Read the "Limitations" and "Known Bugs" sections above, 
just in case.





