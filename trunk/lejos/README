
Summary
-------

Type 'make' to install.

PATH=$PATH:$LEJOS_HOME/bin:$JAVA_HOME/bin
RCXTTY=<serial device>

Exceptions: 
  [XXXX Y], XXXX = method signature; 
            Y    = exception class index % 10.
  Use tvmld -verbose to get class & signature
  indices. Press On/Off to continue.

What is leJOS?
--------------

leJOS is yet another replacement firmware for the Lego
Mindstorms RCX. It was forked out of the TinyVM project
(http://sourceforge.net/projects/tinyvm). leJOS contains
a VM for Java bytecodes, and additional software to load
and run Java programs. These are some of the features
offered by leJOS:

- Object oriented language (Java).
- Arrays.
- Recursion.
- Synchronization.
- Exceptions.
- Preemtive threads of execution.
- Well-documented API.

The above are also provided by TinyVM. But in addition
to these, leJOS also offers:

- Better loader in firmware: you can run a program as
  many times as you want without downloading it every
  time.
- More APIs.
- Floating point operations.
- String constants.
- Comparison and casting of longs (but not arithmetic).
- Marks references in the stack (which makes it feasible
  to implement garbage collection).

TinyVM is still around simply as a low-footprint alternative
to leJOS. The RAM difference between the two is about
??? Kb.

Requirements
------------

- JDK1.1.X or JDK1.2.X, available from http://java.sun.com.
  (The JDK is used during installation, and to run some tools
  provided with leJOS, e.g. the linker).

- leJOS is known to work on Linux, CygWin and Solaris.

Setup
-----

Environment:
  - Your PATH is assumed to point to the 
    JDK's bin directory.
  - You should also add $leJOS_HOME/bin to
    your PATH.
  - RCXTTY must be defined to point to the
    IR device file. For example, in my system
    it's /dev/ttyS1. In Windows (assuming leJOS
    has been ported) it would be COM1, COM2, etc.
  - The leJOSPATH can be used in addition to
    CLASSPATH to allow the linker to locate
    your class files.


Building the Tools:
  Simply go to installation directory and
  type 'make'. At this point all of the tools necessary
  to run leJOS should be available under bin.

Downloading the Firmware:
  Run the tvmfirmdl utility. When the firmware
  starts, the LCD shows the power level (a number
  in the 200s or 300s), and you should hear a 
  double beep.

Example
-------

  1. Go to the example directory.

     cd $leJOS_HOME/examples/hello

  2. Set the CLASSPATH variable.
 
     export CLASSPATH=.

  3. Compile the program.

     tvmc *.java

     Note that this is equivalent to

     javac -classpath .:$leJOS_HOME/lib/classes.jar *.java 

  4. Download firmware, if necessary.

     tvmfirmdl

     This may take a couple of minutes. When the
     firmware is done getting downloaded, you
     should hear two beeps, and the LCD 
     will show the RCX's power level, e.g.

                    [0312 0]

     leJOS is in program-download mode at 
     this point.

     (Note that tvmfirmdl is essentially the same
     as Kekoa Proudfoot's firmdl program, except 
     that tvmfirmdl has been tweaked to allow for
     longer lines in the srec file).

  5. Link & load the program.

     tvmld HelloRCX -d

     This will create a temporary file in the current
     directory, which will be downloaded to the RCX
     using the tvm utility. (This can also be done
     in two steps: tvmld HelloRCX -o HelloRCX.tvm;
     tvm HelloRCX.tvm).

     If the RCX is in range, the LCD will show 
     the download count as  the number of bytes 
     divided by 100. (If nothing happens, make
     sure the RCX is in range. Is the leJOS
     firmware there? If the RCX begins to beep,
     kill tvm, turn off the RCX, wait until the
     IR tower light is off, power up the RCX,
     and try again).

     leJOS will execute the program as soon as
     the download has been completed. When 
     all non-daemon threads are finished, 
     the firmware will return to program-download 
     state. (Note that any pending queued tones 
     will not be heard).

     You can kill any Java program running under
     leJOS by pressing On/Off.
    
     As you may have guessed, you can only 
     download programs when the firmware is in
     program-download state.
     
Footprint
---------

Even though leJOS.srec is about 25 Kb (03/19/00), it
occupies only about 10 Kb in RAM. There's about 18 Kb
of space left for your programs and objects, which is
a very good amount. Run regression/Test13.java if you want
to find out how many empty objects a program can create
before running out of memory.

Emulation
---------

You should be able to run linked programs in the 
development machine. All you need to do is use
tvmld-emul instead of tvmld, and tvm-emul instead
of tvm. In some cases it might be easier to debug
programs with the emulated VM, and you'll also 
get slightly more detailed exception information.

Limitations
-----------

Due to size constraints, some language features
have been omitted. Others just haven't been 
implemented yet. The limitations that come to 
mind are:

  - Garbage collection is not performed.
    (The number of objects in your program
    should be bounded).
  - Switch statements are not supported.
  - Floating point operations are not supported.
  - Operations on variables of type long are not 
    supported.
  - Maximum array length is 255.
  - String constants are not used by the VM to
    create String objects (i.e. don't use Strings).
  - The instanceof operation will always be true  
    for interfaces. In bytecode, CHECKCAST succeeds
    on all interface classes (which is a bit unsafe).
  - The instanceof and checkcast operations are
    rejected by the linker when they are performed
    on array classes (e.g. b instanceof byte[]).
  - All threads are non-daemon threads. 
  - There are no objects of type java.lang.Class, 
    which means that the ".class" construct won't
    work. Class.forName() throws ClassNotFoundException
    at all times.
  - Most JDK APIs are unavailable.

Known Bugs
----------

  - MONITOREXIT ignores null objects (it assumes
    MONITORENTER has handled them). Furthermore, it 
    doesn't check monitor validity. Until this bug 
    is fixed (actually, at all times) all monitors should 
    be constants.

  - Initializers (static or otherwise) are not
    implicitly synchronized. This could lead to race
    conditions. (As an example, consider the hack 
    in classes/leJOS/rcx/Sensor.java:addListener. If Native
    were not forced to get initialized, the listener
    thread may eventually try to use Native.MEMORY_MONITOR,
    which could be null if some other thread is in
    the middle of trying to initialize Native). All this 
    means is that you have to be more careful with 
    initializers and multi-threading than you normally 
    would in a conventional JVM implementation.

  - Unknown native methods are not executed. Neither
    the linker nor the VM complain about them.

Documentation
-------------

A User's Guide is now available at 
  
  http://www.crazyrobots.com/leJOSsite

You should also be able to get the API documentation from
that site, but you can always create your own copy by
running

  cd $leJOS_HOME; make javadoc

About the License
-----------------

I'm releasing under the Mozilla Public License (see LICENSE)
for now, since librcx is under that same license, and leJOS 
is linked against -lrcx. 

Questions/Problems
------------------

Please direct feedback to jhsolorz@yahoo.com.





