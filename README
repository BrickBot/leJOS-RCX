
Summary
-------

TINYVM_HOME=<installation directory>

Type 'make' to install.

PATH=$PATH:$TINYVM_HOME/bin:$JAVA_HOME/bin
RCXTTY=<serial device>

Use TINYVMPATH instead of CLASSPATH.

Tools      : cd $TINYVM_HOME; make
Firmware   : tvmfirmdl
Compiling  : tvmc <class>.java
Linking    : tvmld <class> -o <class>.tvm
Running    : tvm <class>.tvm
Or simply  : tvmld <class> -d

Exceptions: 
  [XXXX Y], XXXX = method signature; 
            Y    = exception class index % 10.
  Press On/Off to continue.

A User's Guide is now available at 
http://www.crazyrobots.com/tinyvmsite. 

What is TinyVM?
---------------

TinyVM is a virtual machine that can execute 
linked Java code inside the Lego Mindstorms RCX. 
It supports several of the most useful features of 
the Java language, such as:

  - Multi-threading.
  - Synchronization.
  - Exceptions.
  - Inner, local and anonymous classes.

It also has a wide range of APIs for controlling
the RCX. The APIs are evolving considerably from 
version to version.

Requirements
------------

- JDK1.1.X or JDK1.2.X, available from http://java.sun.com.
  (The JDK is used during installation, and to run some tools
  provided with TinyVM, e.g. the linker).

- If you're planning to change the source code and
  rebuild it, you should get Kekoa's librcx package,
  build it, and set LIBRCX_HOME to its installation 
  directory. You'd also need gcc and binutils.

Setup
-----

Environment:
  - TINYVM_HOME should point to the TinyVM
    installation directory.
  - Your PATH is assumed to point to the 
    JDK's bin directory.
  - You should also add $TINYVM_HOME/bin to
    your PATH.
  - RCXTTY must be defined to point to the
    IR device file. For example, in my system
    it's /dev/ttyS1. In Windows (assuming TinyVM
    has been ported) it would be COM1, COM2, etc.
  - Before linking, TINYVMPATH should contain
    entries for locating class files, jar files
    or zip files. It works pretty much like
    CLASSPATH does for the JDK.

Building the Tools:
  If you have set TINYVM_HOME correctly, and the JDK's
  bin directory is in your PATH setting, you are ready
  to install TinyVM. Simply go to $TINYVM_HOME and
  type 'make'. At this point all of the tools necessary
  to run TinyVM should be available under bin.

Downloading the Firmware:
  Run the tvmfirmdl utility.

Example
-------

  1. Go to the example directory.

     cd $TINYVM_HOME/examples/hello

  2. Set the TINYVMPATH variable.
 
     export TINYVMPATH=.

  3. Compile the program.

     tvmc *.java

     Note that this is equivalent to

     javac -classpath .:$TINYVM_HOME/lib/classes.jar *.java 

     Do NOT add classes.jar to your CLASSPATH setting.

  4. Download firmware, if necessary.

     tvmfirmdl

     This may take a couple of minutes. When the
     firmware is done getting downloaded, you
     should hear two beeps, and the LCD should 
     look pretty much like this: [0000 0].
     TinyVM is in program-download mode at 
     this point.

     (Note that tvmfirmdl is essentially the same
     as Kekoa Proudfoot's firmdl program, except 
     that tvmfirmdl has been tweaked to allow for
     longer lines in the srec file).

  5. Link & load the program.

     tvmld HelloRCX -d

     This will create a temporary file in the current
     directory, which will be downloaded to the RCX
     using the tvm utility. (This can also be done
     in two steps: tvmld HelloRCX -o HelloRCX.tvm;
     tvm HelloRCX.tvm).

     If the RCX is in range, the LCD will show 
     the download count as  the number of bytes 
     divided by 100. (If nothing happens, make
     sure the RCX is in range. Is the TinyVM
     firmware there? If the RCX begins to beep,
     kill tvm, turn off the RCX, wait until the
     IR tower light is off, power up the RCX,
     and try again).

     TinyVM will execute the program as soon as
     the download has been completed. When 
     all non-daemon threads are finished, 
     the firmware will return to program-download 
     state. (Note that any pending queued tones 
     will not be heard).

     You can kill any Java program running in the
     RCX by pressing On/Off.
    
     As you may have guessed, you can only 
     download programs when the firmware is in
     program-download state.
     
Exceptions
----------

(See User's Guide at http://www.crazyrobots.com/tinyvmsite).

Footprint
---------

Even though tinyvm.srec is about 25 Kb (03/19/00), it
occupies only about 10 Kb in RAM. There's about 18 Kb
of space left for your programs and objects, which is
a very good amount. Run regression/Test13.java if you want
to find out how many empty objects a program can create
before running out of memory.

Emulation
---------

You should be able to run linked programs in the 
development machine. All you need to do is use
tvmld-emul instead of tvmld, and tvm-emul instead
of tvm. In some cases it might be easier to debug
programs with the emulated VM, and you'll also 
get slightly more detailed exception information.

Limitations
-----------

Due to size constraints, some language features
have been omitted. Others just haven't been 
implemented yet. The limitations that come to 
mind are:

  - Garbage collection is not performed.
    (The number of objects in your program
    should be bounded).
  - Switch statements are not supported.
  - Floating point operations are not supported.
  - Operations on variables of type long are not 
    supported.
  - Maximum array length is 255.
  - String constants are not used by the VM to
    create String objects (i.e. don't use Strings).
  - The instanceof operation will always be true  
    for interfaces. In bytecode, CHECKCAST succeeds
    on all interface classes (which is a bit unsafe).
  - All threads are non-daemon threads. 
  - There are no objects of type java.lang.Class, 
    which means that the ".class" construct won't
    work. Class.forName() throws ClassNotFoundException
    at all times.
  - Most JDK APIs are unavailable.

Known Bugs
----------

  - MONITOREXIT ignores null objects (it assumes
    MONITORENTER has handled them). Furthermore, it 
    doesn't check monitor validity. Until this bug 
    is fixed (actually, at all times) all monitors should 
    be constants.

  - Initializers (static or otherwise) are not
    implicitly synchronized. This could lead to race
    conditions. (As an example, consider the hack 
    in classes/tinyvm/rcx/Sensor.java:addListener. If Native
    were not forced to get initialized, the listener
    thread may eventually try to use Native.MEMORY_MONITOR,
    which could be null if some other thread is in
    the middle of trying to initialize Native). All this 
    means is that you have to be more careful with 
    initializers and multi-threading than you normally 
    would in a conventional JVM implementation.

  - Unknown native methods are not executed. Neither
    the linker nor the VM complain about them.

Documentation
-------------

A User's Guide is now available at 
  
  http://www.crazyrobots.com/tinyvmsite

You should also be able to get the API documentation from
that site, but you can always create your own copy by
running

  cd $TINYVM_HOME; make javadoc

About the License
-----------------

I'm releasing under the Mozilla Public License (see LICENSE)
for now, since librcx is under that same license, and TinyVM 
is linked against -lrcx. TinyVM is copyright (c) 2000 Jose
Solorzano.

Questions/Problems
------------------

You can contact Jose at jhsolorz@yahoo.com if you 
have any questions, problems, or if you'd like to
contribute to TinyVM in any way.

Read the "Limitations" and "Known Bugs" sections above, 
just in case.






